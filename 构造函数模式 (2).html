<!DOCTYPE html>
<html>
<head>
	<title>构造函数模式</title>
</head>
<body>
	<script>
	/*this指向create，argumets.length=3*/
	// function create(name,age,jobs){
	// 	this.name = name;
	// 	this.age = age;
	// 	this.jobs = jobs;
	// 	this.set = function(){
	// 		alert(this.name);
	// 	}
	// }
	// /*因为new的新对象是create，可以知道this指向create*/
	// var per1 = new create('dede','23','code');
	// var per2 = new create('derf','233','co3333de');
	// per1.set();


	//=========================================================================================================================
	/*原型模式*/
	// function Person(){};

	// Person.prototype = {
	//     constructor:Person,
	//     name:'nnn',
	//     sayName:function (){
	//         alert(this.name);
	//     }
	// };
	// var friend = new Person();
	// friend.sayName();
	//原型模式最重要的问题是由于他的共享本质导致的，对于引用类型来说，会一个实例里面的值发生改变使另一个实例里面的值随之改变

	//===================================================================================================================================
	/*组合使用构造函数模式和原型模式*/
	//构造函数模式定义实例属性
	// function Person(name,age,jobs){
	// 	this.name = name;
	// 	this.age = age;
	// 	this.jobs = jobs;
	// 	this.friends = ['dfsg'];//数组对象初始化的值
	// } 
	// //定义方法和共享的属性
	// Person.prototype = {
	// 	constructor : Person,//构造函数
	// 	sayName:function(){
	// 		alert(this.name);
	// 	}
	// }
	// var friends1 = new Person("dsfds","22","hhh");
	// var friends0 = new Person("dsfg","44","ert");

	// friends0.friends.push("far");
	// console.log(friends1.friends);
	// console.log(friends0.friends);


	//=================================================================================================================================
	//闭包
	// function foo1(){
	// 	var n = 99;
	// 	return function foo2(){
	// 		alert(n);
	// 	}
	// }
	// var res = foo1();
	// res();
	

// 	var name = "The Window";
// 　　var object = {
// 　　　　name : "My Object",
// 　　　　getNameFunc : function(){
// 　　　　　　return function(){
// 　　　　　　　　return this.name;//匿名函数的执行环境具有全局性，所以this指向window
// 　　　　　　};
// 　　　　}
// 　　};
// 　　alert(object.getNameFunc()());
var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;//that引用着object
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());

// var a = function(){
// 	this.a = 3;
// }

// a.prototype.b = 1;

// var c = new a();



// c._proto_.b = 3;alert(c.b);


//=============================================================================================================================================
//QuickSort
// var quickSort = function(arr){
// 	if(arr.length<=1){
// 		return arr;
// 	}
// 	var index = Math.floor(arr.length/2);
// 	var  oId = arr.splice(index,1)[0];
// 	var left = [];
// 	var right = [];
// 	for(var i = 0;i<arr.length;i++){
// 	 	if(arr[i]<oId){
// 	 		left.push(arr[i]);
// 	 	}else{
// 	 		right.push(arr[i]);
// 	 	}	
// 	}
// 	return quickSort(left).concat([oId],quickSort(right));
// } 

// var arr = ['34','546','3'];
// console.log(quickSort(arr));


//==============================================================================================================================================
//数组去重


//==============================================================================================================================================
//自定义事件
	// var Event = {
	// 	_listener:{},
	// 	addEvent:function(type,fn){
			
	// 	},
	// 	triggerEvent:function(type){

	// 	},
	// 	removeEvent:function(type,fn){

	// 	}
	// }
	</script>
</body>
</html>